// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v4.25.3
// source: rootlayer/service.proto

package rootpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	IntentPoolService_SubmitIntent_FullMethodName           = "/rootlayer.v1.IntentPoolService/SubmitIntent"
	IntentPoolService_GetIntents_FullMethodName             = "/rootlayer.v1.IntentPoolService/GetIntents"
	IntentPoolService_GetIntent_FullMethodName              = "/rootlayer.v1.IntentPoolService/GetIntent"
	IntentPoolService_PostAssignment_FullMethodName         = "/rootlayer.v1.IntentPoolService/PostAssignment"
	IntentPoolService_PostAssignments_FullMethodName        = "/rootlayer.v1.IntentPoolService/PostAssignments"
	IntentPoolService_SubmitValidationBundle_FullMethodName = "/rootlayer.v1.IntentPoolService/SubmitValidationBundle"
)

// IntentPoolServiceClient is the client API for IntentPoolService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// IntentPoolService exposes REST endpoints for intent submission,
// querying, and asynchronous callbacks from subnets.
type IntentPoolServiceClient interface {
	// Submit a new intent into the RootLayer mempool.
	//
	// Body is a SubmitIntentRequest. The signature proves ownership of
	// the requester address and integrity of parameters.
	//
	// Example request body:
	//
	//	{
	//	  "intentId": "0xb7c98798a6ec454427a60cff94b54276fe82396f714c02499a40c8f3f6325f8d",
	//	  "subnetId": "0x0000000000000000000000000000000000000000000000000000000000000001",
	//	  "requester": "0x9290085Cd66bD1A3C7D277EF7DBcbD2e98457b6f",
	//	  "settleChain": "base_sepolia",
	//	  "intentType": "test",
	//	  "params": {
	//	    "intentRaw": "cGluZ3Jhdw==",
	//	    "metadata": "LXRlc3QgbWV0YS0="
	//	  },
	//	  "tipsToken": "0x0000000000000000000000000000000000000000",
	//	  "tips": "0",
	//	  "deadline": "1822275330",
	//	  "signature": "cfe0c61b6c01fb6b907fd11e550797c761b2cecbc7a3d59e8775fe8640b88c5f1f297f7fdb321c3d1122",
	//	  "budgetToken": "0x0000000000000000000000000000000000000000",
	//	  "budget": "0"
	//	}
	SubmitIntent(ctx context.Context, in *SubmitIntentRequest, opts ...grpc.CallOption) (*SubmitIntentResponse, error)
	// Query intents using multiple filters with pagination.
	GetIntents(ctx context.Context, in *GetIntentsRequest, opts ...grpc.CallOption) (*GetIntentsResponse, error)
	// Fetch a single intent by its ID.
	GetIntent(ctx context.Context, in *GetIntentRequest, opts ...grpc.CallOption) (*Intent, error)
	// Post a single assignment from a subnet matcher.
	//
	// Example request body:
	//
	//	{
	//	  "assignmentId": "84DDC59E-4048-41C9-A620-FF43C7BE08FA",
	//	  "intentId": "0xb7c98798a6ec454427a60cff94b54276fe82396f714c02499a40c8f3f6325f8d",
	//	  "agentId": "6CF637B0-8D48-489E-B899-467D99D842FF",
	//	  "bidId": "0F6E6E64-EF8F-4A69-90BE-A9B0490CEF2E",
	//	  "status": 1,
	//	  "matcherId": "ACA2F35F-97E2-4D69-B4BD-771EDACD1DEB",
	//	  "signature": "tempor"
	//	}
	PostAssignment(ctx context.Context, in *Assignment, opts ...grpc.CallOption) (*Ack, error)
	// Post a batch of assignments from a subnet matcher.
	PostAssignments(ctx context.Context, in *AssignmentBatch, opts ...grpc.CallOption) (*Ack, error)
	// Submit an aggregated ValidationBundle from subnet validators.
	//
	// Example request body:
	//
	//	{
	//	  "subnetId": "0x0000000000000000000000000000000000000000000000000000000000000001",
	//	  "intentId": "0xb7c98798a6ec454427a60cff94b54276fe82396f714c02499a40c8f3f6325f8d",
	//	  "assignmentId": "84DDC59E-4048-41C9-A620-FF43C7BE08FA",
	//	  "agentId": "6CF637B0-8D48-489E-B899-467D99D842FF",
	//	  "rootHeight": "1",
	//	  "rootHash": "0x01",
	//	  "executedAt": "1",
	//	  "resultHash": "0x01",
	//	  "proofHash": "0x01",
	//	  "signatures": [
	//	    { "validatorId": "75", "signature": "0x01", "msgHash": "0x01", "pubkey": "0x01" }
	//	  ],
	//	  "signerBitmap": "0x01",
	//	  "totalWeight": "1",
	//	  "aggregatorId": "46",
	//	  "completedAt": "1822275330"
	//	}
	SubmitValidationBundle(ctx context.Context, in *ValidationBundle, opts ...grpc.CallOption) (*ValidationAck, error)
}

type intentPoolServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIntentPoolServiceClient(cc grpc.ClientConnInterface) IntentPoolServiceClient {
	return &intentPoolServiceClient{cc}
}

func (c *intentPoolServiceClient) SubmitIntent(ctx context.Context, in *SubmitIntentRequest, opts ...grpc.CallOption) (*SubmitIntentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitIntentResponse)
	err := c.cc.Invoke(ctx, IntentPoolService_SubmitIntent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intentPoolServiceClient) GetIntents(ctx context.Context, in *GetIntentsRequest, opts ...grpc.CallOption) (*GetIntentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetIntentsResponse)
	err := c.cc.Invoke(ctx, IntentPoolService_GetIntents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intentPoolServiceClient) GetIntent(ctx context.Context, in *GetIntentRequest, opts ...grpc.CallOption) (*Intent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Intent)
	err := c.cc.Invoke(ctx, IntentPoolService_GetIntent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intentPoolServiceClient) PostAssignment(ctx context.Context, in *Assignment, opts ...grpc.CallOption) (*Ack, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Ack)
	err := c.cc.Invoke(ctx, IntentPoolService_PostAssignment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intentPoolServiceClient) PostAssignments(ctx context.Context, in *AssignmentBatch, opts ...grpc.CallOption) (*Ack, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Ack)
	err := c.cc.Invoke(ctx, IntentPoolService_PostAssignments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intentPoolServiceClient) SubmitValidationBundle(ctx context.Context, in *ValidationBundle, opts ...grpc.CallOption) (*ValidationAck, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidationAck)
	err := c.cc.Invoke(ctx, IntentPoolService_SubmitValidationBundle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IntentPoolServiceServer is the server API for IntentPoolService service.
// All implementations must embed UnimplementedIntentPoolServiceServer
// for forward compatibility.
//
// IntentPoolService exposes REST endpoints for intent submission,
// querying, and asynchronous callbacks from subnets.
type IntentPoolServiceServer interface {
	// Submit a new intent into the RootLayer mempool.
	//
	// Body is a SubmitIntentRequest. The signature proves ownership of
	// the requester address and integrity of parameters.
	//
	// Example request body:
	//
	//	{
	//	  "intentId": "0xb7c98798a6ec454427a60cff94b54276fe82396f714c02499a40c8f3f6325f8d",
	//	  "subnetId": "0x0000000000000000000000000000000000000000000000000000000000000001",
	//	  "requester": "0x9290085Cd66bD1A3C7D277EF7DBcbD2e98457b6f",
	//	  "settleChain": "base_sepolia",
	//	  "intentType": "test",
	//	  "params": {
	//	    "intentRaw": "cGluZ3Jhdw==",
	//	    "metadata": "LXRlc3QgbWV0YS0="
	//	  },
	//	  "tipsToken": "0x0000000000000000000000000000000000000000",
	//	  "tips": "0",
	//	  "deadline": "1822275330",
	//	  "signature": "cfe0c61b6c01fb6b907fd11e550797c761b2cecbc7a3d59e8775fe8640b88c5f1f297f7fdb321c3d1122",
	//	  "budgetToken": "0x0000000000000000000000000000000000000000",
	//	  "budget": "0"
	//	}
	SubmitIntent(context.Context, *SubmitIntentRequest) (*SubmitIntentResponse, error)
	// Query intents using multiple filters with pagination.
	GetIntents(context.Context, *GetIntentsRequest) (*GetIntentsResponse, error)
	// Fetch a single intent by its ID.
	GetIntent(context.Context, *GetIntentRequest) (*Intent, error)
	// Post a single assignment from a subnet matcher.
	//
	// Example request body:
	//
	//	{
	//	  "assignmentId": "84DDC59E-4048-41C9-A620-FF43C7BE08FA",
	//	  "intentId": "0xb7c98798a6ec454427a60cff94b54276fe82396f714c02499a40c8f3f6325f8d",
	//	  "agentId": "6CF637B0-8D48-489E-B899-467D99D842FF",
	//	  "bidId": "0F6E6E64-EF8F-4A69-90BE-A9B0490CEF2E",
	//	  "status": 1,
	//	  "matcherId": "ACA2F35F-97E2-4D69-B4BD-771EDACD1DEB",
	//	  "signature": "tempor"
	//	}
	PostAssignment(context.Context, *Assignment) (*Ack, error)
	// Post a batch of assignments from a subnet matcher.
	PostAssignments(context.Context, *AssignmentBatch) (*Ack, error)
	// Submit an aggregated ValidationBundle from subnet validators.
	//
	// Example request body:
	//
	//	{
	//	  "subnetId": "0x0000000000000000000000000000000000000000000000000000000000000001",
	//	  "intentId": "0xb7c98798a6ec454427a60cff94b54276fe82396f714c02499a40c8f3f6325f8d",
	//	  "assignmentId": "84DDC59E-4048-41C9-A620-FF43C7BE08FA",
	//	  "agentId": "6CF637B0-8D48-489E-B899-467D99D842FF",
	//	  "rootHeight": "1",
	//	  "rootHash": "0x01",
	//	  "executedAt": "1",
	//	  "resultHash": "0x01",
	//	  "proofHash": "0x01",
	//	  "signatures": [
	//	    { "validatorId": "75", "signature": "0x01", "msgHash": "0x01", "pubkey": "0x01" }
	//	  ],
	//	  "signerBitmap": "0x01",
	//	  "totalWeight": "1",
	//	  "aggregatorId": "46",
	//	  "completedAt": "1822275330"
	//	}
	SubmitValidationBundle(context.Context, *ValidationBundle) (*ValidationAck, error)
	mustEmbedUnimplementedIntentPoolServiceServer()
}

// UnimplementedIntentPoolServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedIntentPoolServiceServer struct{}

func (UnimplementedIntentPoolServiceServer) SubmitIntent(context.Context, *SubmitIntentRequest) (*SubmitIntentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitIntent not implemented")
}
func (UnimplementedIntentPoolServiceServer) GetIntents(context.Context, *GetIntentsRequest) (*GetIntentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntents not implemented")
}
func (UnimplementedIntentPoolServiceServer) GetIntent(context.Context, *GetIntentRequest) (*Intent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntent not implemented")
}
func (UnimplementedIntentPoolServiceServer) PostAssignment(context.Context, *Assignment) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostAssignment not implemented")
}
func (UnimplementedIntentPoolServiceServer) PostAssignments(context.Context, *AssignmentBatch) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostAssignments not implemented")
}
func (UnimplementedIntentPoolServiceServer) SubmitValidationBundle(context.Context, *ValidationBundle) (*ValidationAck, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitValidationBundle not implemented")
}
func (UnimplementedIntentPoolServiceServer) mustEmbedUnimplementedIntentPoolServiceServer() {}
func (UnimplementedIntentPoolServiceServer) testEmbeddedByValue()                           {}

// UnsafeIntentPoolServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IntentPoolServiceServer will
// result in compilation errors.
type UnsafeIntentPoolServiceServer interface {
	mustEmbedUnimplementedIntentPoolServiceServer()
}

func RegisterIntentPoolServiceServer(s grpc.ServiceRegistrar, srv IntentPoolServiceServer) {
	// If the following call pancis, it indicates UnimplementedIntentPoolServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&IntentPoolService_ServiceDesc, srv)
}

func _IntentPoolService_SubmitIntent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitIntentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntentPoolServiceServer).SubmitIntent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntentPoolService_SubmitIntent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntentPoolServiceServer).SubmitIntent(ctx, req.(*SubmitIntentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntentPoolService_GetIntents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIntentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntentPoolServiceServer).GetIntents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntentPoolService_GetIntents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntentPoolServiceServer).GetIntents(ctx, req.(*GetIntentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntentPoolService_GetIntent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIntentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntentPoolServiceServer).GetIntent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntentPoolService_GetIntent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntentPoolServiceServer).GetIntent(ctx, req.(*GetIntentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntentPoolService_PostAssignment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Assignment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntentPoolServiceServer).PostAssignment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntentPoolService_PostAssignment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntentPoolServiceServer).PostAssignment(ctx, req.(*Assignment))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntentPoolService_PostAssignments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignmentBatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntentPoolServiceServer).PostAssignments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntentPoolService_PostAssignments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntentPoolServiceServer).PostAssignments(ctx, req.(*AssignmentBatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntentPoolService_SubmitValidationBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidationBundle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntentPoolServiceServer).SubmitValidationBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntentPoolService_SubmitValidationBundle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntentPoolServiceServer).SubmitValidationBundle(ctx, req.(*ValidationBundle))
	}
	return interceptor(ctx, in, info, handler)
}

// IntentPoolService_ServiceDesc is the grpc.ServiceDesc for IntentPoolService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IntentPoolService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rootlayer.v1.IntentPoolService",
	HandlerType: (*IntentPoolServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitIntent",
			Handler:    _IntentPoolService_SubmitIntent_Handler,
		},
		{
			MethodName: "GetIntents",
			Handler:    _IntentPoolService_GetIntents_Handler,
		},
		{
			MethodName: "GetIntent",
			Handler:    _IntentPoolService_GetIntent_Handler,
		},
		{
			MethodName: "PostAssignment",
			Handler:    _IntentPoolService_PostAssignment_Handler,
		},
		{
			MethodName: "PostAssignments",
			Handler:    _IntentPoolService_PostAssignments_Handler,
		},
		{
			MethodName: "SubmitValidationBundle",
			Handler:    _IntentPoolService_SubmitValidationBundle_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rootlayer/service.proto",
}

const (
	SubscriptionService_SubscribeIntents_FullMethodName       = "/rootlayer.v1.SubscriptionService/SubscribeIntents"
	SubscriptionService_SubscribeStatusUpdates_FullMethodName = "/rootlayer.v1.SubscriptionService/SubscribeStatusUpdates"
)

// SubscriptionServiceClient is the client API for SubscriptionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// gRPC streaming subscription service (not exposed via OpenAPI).
type SubscriptionServiceClient interface {
	// Subscribe to the real-time intent stream filtered by subnet and metadata.
	SubscribeIntents(ctx context.Context, in *SubscribeIntentsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[IntentStreamEvent], error)
	// Subscribe to status change notifications for one or more intents.
	SubscribeStatusUpdates(ctx context.Context, in *SubscribeStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StatusUpdateEvent], error)
}

type subscriptionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSubscriptionServiceClient(cc grpc.ClientConnInterface) SubscriptionServiceClient {
	return &subscriptionServiceClient{cc}
}

func (c *subscriptionServiceClient) SubscribeIntents(ctx context.Context, in *SubscribeIntentsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[IntentStreamEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SubscriptionService_ServiceDesc.Streams[0], SubscriptionService_SubscribeIntents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeIntentsRequest, IntentStreamEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SubscriptionService_SubscribeIntentsClient = grpc.ServerStreamingClient[IntentStreamEvent]

func (c *subscriptionServiceClient) SubscribeStatusUpdates(ctx context.Context, in *SubscribeStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StatusUpdateEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SubscriptionService_ServiceDesc.Streams[1], SubscriptionService_SubscribeStatusUpdates_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeStatusRequest, StatusUpdateEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SubscriptionService_SubscribeStatusUpdatesClient = grpc.ServerStreamingClient[StatusUpdateEvent]

// SubscriptionServiceServer is the server API for SubscriptionService service.
// All implementations must embed UnimplementedSubscriptionServiceServer
// for forward compatibility.
//
// gRPC streaming subscription service (not exposed via OpenAPI).
type SubscriptionServiceServer interface {
	// Subscribe to the real-time intent stream filtered by subnet and metadata.
	SubscribeIntents(*SubscribeIntentsRequest, grpc.ServerStreamingServer[IntentStreamEvent]) error
	// Subscribe to status change notifications for one or more intents.
	SubscribeStatusUpdates(*SubscribeStatusRequest, grpc.ServerStreamingServer[StatusUpdateEvent]) error
	mustEmbedUnimplementedSubscriptionServiceServer()
}

// UnimplementedSubscriptionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSubscriptionServiceServer struct{}

func (UnimplementedSubscriptionServiceServer) SubscribeIntents(*SubscribeIntentsRequest, grpc.ServerStreamingServer[IntentStreamEvent]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeIntents not implemented")
}
func (UnimplementedSubscriptionServiceServer) SubscribeStatusUpdates(*SubscribeStatusRequest, grpc.ServerStreamingServer[StatusUpdateEvent]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeStatusUpdates not implemented")
}
func (UnimplementedSubscriptionServiceServer) mustEmbedUnimplementedSubscriptionServiceServer() {}
func (UnimplementedSubscriptionServiceServer) testEmbeddedByValue()                             {}

// UnsafeSubscriptionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SubscriptionServiceServer will
// result in compilation errors.
type UnsafeSubscriptionServiceServer interface {
	mustEmbedUnimplementedSubscriptionServiceServer()
}

func RegisterSubscriptionServiceServer(s grpc.ServiceRegistrar, srv SubscriptionServiceServer) {
	// If the following call pancis, it indicates UnimplementedSubscriptionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SubscriptionService_ServiceDesc, srv)
}

func _SubscriptionService_SubscribeIntents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeIntentsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SubscriptionServiceServer).SubscribeIntents(m, &grpc.GenericServerStream[SubscribeIntentsRequest, IntentStreamEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SubscriptionService_SubscribeIntentsServer = grpc.ServerStreamingServer[IntentStreamEvent]

func _SubscriptionService_SubscribeStatusUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeStatusRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SubscriptionServiceServer).SubscribeStatusUpdates(m, &grpc.GenericServerStream[SubscribeStatusRequest, StatusUpdateEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SubscriptionService_SubscribeStatusUpdatesServer = grpc.ServerStreamingServer[StatusUpdateEvent]

// SubscriptionService_ServiceDesc is the grpc.ServiceDesc for SubscriptionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SubscriptionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rootlayer.v1.SubscriptionService",
	HandlerType: (*SubscriptionServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeIntents",
			Handler:       _SubscriptionService_SubscribeIntents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeStatusUpdates",
			Handler:       _SubscriptionService_SubscribeStatusUpdates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rootlayer/service.proto",
}

const (
	HealthService_Check_FullMethodName = "/rootlayer.v1.HealthService/Check"
)

// HealthServiceClient is the client API for HealthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Liveness and version information.
type HealthServiceClient interface {
	Check(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type healthServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthServiceClient(cc grpc.ClientConnInterface) HealthServiceClient {
	return &healthServiceClient{cc}
}

func (c *healthServiceClient) Check(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, HealthService_Check_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthServiceServer is the server API for HealthService service.
// All implementations must embed UnimplementedHealthServiceServer
// for forward compatibility.
//
// Liveness and version information.
type HealthServiceServer interface {
	Check(context.Context, *emptypb.Empty) (*HealthCheckResponse, error)
	mustEmbedUnimplementedHealthServiceServer()
}

// UnimplementedHealthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHealthServiceServer struct{}

func (UnimplementedHealthServiceServer) Check(context.Context, *emptypb.Empty) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Check not implemented")
}
func (UnimplementedHealthServiceServer) mustEmbedUnimplementedHealthServiceServer() {}
func (UnimplementedHealthServiceServer) testEmbeddedByValue()                       {}

// UnsafeHealthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthServiceServer will
// result in compilation errors.
type UnsafeHealthServiceServer interface {
	mustEmbedUnimplementedHealthServiceServer()
}

func RegisterHealthServiceServer(s grpc.ServiceRegistrar, srv HealthServiceServer) {
	// If the following call pancis, it indicates UnimplementedHealthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HealthService_ServiceDesc, srv)
}

func _HealthService_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServiceServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthService_Check_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServiceServer).Check(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// HealthService_ServiceDesc is the grpc.ServiceDesc for HealthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rootlayer.v1.HealthService",
	HandlerType: (*HealthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Check",
			Handler:    _HealthService_Check_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rootlayer/service.proto",
}
